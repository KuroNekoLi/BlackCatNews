require "securerandom"
require "base64"
require "spaceship"

default_platform(:ios)

platform :ios do
  # ===== å…±ç”¨é…ç½® =====
  BUNDLE_ID = "com.linli.blackcatnews"
  TARGET_NAME = "iosApp"
  OUTPUT_NAME = "BlackCatNews"

  before_all do
    @root_dir = File.expand_path('../..', __dir__)
    @gradlew = File.join(@root_dir, 'gradlew')
    @ios_proj_dir = File.expand_path('..', __dir__)
    @project_path = File.join(@ios_proj_dir, "#{TARGET_NAME}.xcodeproj")
    @workspace_path = File.join(@ios_proj_dir, "#{TARGET_NAME}.xcworkspace")
    @xcconfig_path = File.join(@ios_proj_dir, 'Configuration/Config.xcconfig')
  end

  # ===== ç§æœ‰è¼”åŠ©æ–¹æ³• =====
  private_lane :validate_api_key_env do
    required = ["ASC_KEY_ID", "ASC_ISSUER_ID"]
    required << (ENV["ASC_PRIVATE_KEY"] || ENV["ASC_PRIVATE_KEY_BASE64"] ? nil : "ASC_PRIVATE_KEY")
    missing = required.compact.reject { |k| ENV[k] }
    UI.user_error!("ç¼ºå°‘ App Store Connect API é‡‘é‘°ï¼š#{missing.join(', ')}") unless missing.empty?
  end

  private_lane :get_api_key do
    validate_api_key_env
    UI.message("ğŸ”‘ ä½¿ç”¨ App Store Connect API Key èªè­‰")
    app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty? ? ENV["ASC_PRIVATE_KEY"] : ENV["ASC_PRIVATE_KEY_BASE64"],
      is_key_content_base64: !ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty?
    )
  end

  private_lane :generate_podspec do
    UI.message("ğŸ”§ ç”Ÿæˆ podspec å’Œ dummy frameworks")
    sh %Q{#{@gradlew} -p "#{@root_dir}" :composeApp:podspec :core:authentication:podspec :composeApp:generateDummyFramework :core:authentication:generateDummyFramework --no-daemon --stacktrace}, log: true
    sh %Q{bundle exec pod install --project-directory="#{@ios_proj_dir}" --repo-update}, log: true
  end

  private_lane :create_temp_keychain do |options|
    name = options[:name] || "fastlane_manual_tmp"
    password = SecureRandom.uuid
    path = File.expand_path("~/Library/Keychains/#{name}-db")

    UI.message("ğŸ” å‰µå»ºè‡¨æ™‚ keychain: #{name}")
    create_keychain(
      name: name,
      password: password,
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false,
      require_create: true
    )

    { name: name, password: password, path: path }
  end

  private_lane :import_distribution_cert do |options|
    unless (ENV["IOS_DIST_CERT_BASE64"] || ENV["IOS_DIST_CERT_PATH"]) && ENV["IOS_DIST_CERT_PASSWORD"]
      UI.user_error!("ç¼ºå°‘ç™¼è¡Œæ†‘è­‰è¨­å®šï¼šéœ€è¦ IOS_DIST_CERT_BASE64 æˆ– IOS_DIST_CERT_PATHï¼Œä»¥åŠ IOS_DIST_CERT_PASSWORD")
    end

    cert_path = ENV["IOS_DIST_CERT_PATH"]
    if cert_path.to_s.empty?
      cert_path = File.join(Dir.pwd, options[:filename] || "dist_cert.p12")
      File.binwrite(cert_path, Base64.decode64(ENV["IOS_DIST_CERT_BASE64"]))
    end

    UI.message("ğŸ” åŒ¯å…¥ Distribution æ†‘è­‰åˆ°è‡¨æ™‚ keychain")
    import_certificate(
      certificate_path: cert_path,
      certificate_password: ENV["IOS_DIST_CERT_PASSWORD"],
      keychain_path: options[:keychain_path],
      keychain_password: options[:keychain_password]
    )
  end

  private_lane :setup_code_signing do |options|
    api_key = options[:api_key]

    sigh(
      api_key: api_key,
      app_identifier: BUNDLE_ID,
      force: true
    )

    profile_uuid = lane_context[SharedValues::SIGH_UUID]
    profile_name = lane_context[SharedValues::SIGH_NAME]
    UI.message("ğŸ“‹ ä½¿ç”¨æè¿°æª”: #{profile_name} (#{profile_uuid})")

    update_code_signing_settings(
      use_automatic_signing: false,
      path: @project_path,
      targets: [TARGET_NAME],
      build_configurations: ["Release"],
      team_id: ENV["APPLE_TEAM_ID"],
      code_sign_identity: "Apple Distribution",
      profile_name: profile_name
    )

    profile_name
  end

  # ===== ç‰ˆæœ¬ç®¡ç†è¼”åŠ©æ–¹æ³• =====
  private_lane :parse_version do |options|
    version = options[:version]
    version.to_s.strip.split('.').map(&:to_i)
  end

  private_lane :compare_versions do |options|
    a = options[:a]
    b = options[:b]
    ax = parse_version(version: a)
    bx = parse_version(version: b)
    result = 0
    (0..2).each do |i|
      ai = ax[i] || 0
      bi = bx[i] || 0
      if ai != bi
        result = (ai <=> bi)
        break
      end
    end
    result
  end

  private_lane :bump_patch_version do |options|
    version = options[:version]
    parts = parse_version(version: version)
    parts[0] ||= 1
    parts[1] ||= 0
    parts[2] ||= 0
    parts[2] += 1
    "%d.%d.%d" % parts[0..2]
  end

  private_lane :get_live_app_store_version do
    begin
      token = Spaceship::ConnectAPI::Token.create(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key: ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty? ? ENV["ASC_PRIVATE_KEY"] : ENV["ASC_PRIVATE_KEY_BASE64"],
        is_key_content_base64: !ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty?
      )
      Spaceship::ConnectAPI.token = token
      app = Spaceship::ConnectAPI::App.find(BUNDLE_ID)
      app.get_live_app_store_version&.version_string
    rescue => e
      UI.important("âš ï¸ ç„¡æ³•æŸ¥è©¢ App Store å·²æ ¸å‡†ç‰ˆæœ¬ï¼š#{e.message}")
      nil
    end
  end

  private_lane :calculate_next_version do |options|
    current_version = options[:current] || "1.0.0"

    # æª¢æŸ¥æ˜¯å¦ç”± tag è§¸ç™¼
    ref_type = ENV['GITHUB_REF_TYPE'].to_s
    ref_name = ENV['GITHUB_REF_NAME'].to_s

    if ref_type == 'tag' && ref_name =~ /^ios-(?:beta-)?v(\d+\.\d+\.\d+)$/
      desired = Regexp.last_match(1)
    else
      desired = bump_patch_version(version: current_version)
    end

    # ç¢ºä¿é«˜æ–¼ App Store å·²æ ¸å‡†ç‰ˆæœ¬
    if (live_version = get_live_app_store_version)
      if compare_versions(a: desired, b: live_version) <= 0
        UI.important("âš ï¸ App Store å·²æ ¸å‡†ç‰ˆæœ¬ç‚º #{live_version}ï¼Œè‡ªå‹•æå‡ç‰ˆæœ¬è™Ÿ")
        desired = bump_patch_version(version: live_version)
      end
    end

    # ç¢ºä¿é«˜æ–¼å°ˆæ¡ˆç•¶å‰ç‰ˆæœ¬
    if compare_versions(a: desired, b: current_version) <= 0
      desired = bump_patch_version(version: current_version)
    end

    desired
  end

  private_lane :update_version_and_build do |options|
    api_key = options[:api_key]
    version = options[:version]

    UI.message("ğŸ“Œ è¨­å®š MARKETING_VERSION: #{version} (åƒ…åœ¨å»ºç½®æ™‚è¨­å®šï¼Œä¸å¯«å…¥ Config.xcconfig)")

    begin
      increment_version_number(xcodeproj: @project_path, version_number: version)
    rescue => e
      UI.important("âš ï¸ ç„¡æ³•æ›´æ–° xcodeproj MARKETING_VERSIONï¼š#{e.message}")
    end

    begin
      latest_build = latest_testflight_build_number(
        app_identifier: BUNDLE_ID,
        version: version,
        api_key: api_key
      )
      next_build = latest_build.to_i + 1
      UI.message("ğŸ”¢ è¨­å®š CFBundleVersion: #{next_build} (TestFlight æœ€æ–° build ç‚º #{latest_build})")
      increment_build_number(build_number: next_build, xcodeproj: @project_path)
      next_build
    rescue => e
      UI.important("âš ï¸ ç„¡æ³•è®€å– TestFlight buildï¼š#{e.message}ï¼Œä½¿ç”¨ build=1")
      increment_build_number(build_number: 1, xcodeproj: @project_path)
      1
    end
  end

  private_lane :clean_gradle_cache do
    sh %Q{#{@gradlew} --stop || true}
    sh %Q{rm -rf "#{@root_dir}/.gradle/configuration-cache"}
  end

  private_lane :build_ipa do |options|
    keychain_path = options[:keychain_path]
    profile_name = options[:profile_name]
    version = options[:version]
    build_number = options[:build_number]

    gym(
      workspace: @workspace_path,
      scheme: TARGET_NAME,
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      include_bitcode: false,
      export_options: {
        method: "app-store",
        signingStyle: "manual",
        provisioningProfiles: { BUNDLE_ID => profile_name }
      },
      xcargs: [
        "-allowProvisioningUpdates",
        "OTHER_CODE_SIGN_FLAGS='--keychain #{keychain_path}'",
        "MARKETING_VERSION=#{version}",
        "CURRENT_PROJECT_VERSION=#{build_number}",
        "-jobs 1"
      ].join(" "),
      output_directory: @ios_proj_dir,
      output_name: OUTPUT_NAME
    )
  end

  private_lane :verify_ipa_version do |options|
    version = options[:version]
    build_number = options[:build_number]
    ipa_path = File.join(@ios_proj_dir, "#{OUTPUT_NAME}.ipa")

    UI.message("âœ… é©—è­‰ IPA ç‰ˆæœ¬è³‡è¨Š")
    begin
      sh %Q{
        tmpdir=$(mktemp -d) &&
        unzip -q "#{ipa_path}" -d "$tmpdir" &&
        IPA_VER=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$tmpdir/Payload/#{OUTPUT_NAME}.app/Info.plist") &&
        IPA_BUILD=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$tmpdir/Payload/#{OUTPUT_NAME}.app/Info.plist") &&
        echo "ğŸ“¦ IPA ç‰ˆæœ¬è³‡è¨Šï¼šCFBundleShortVersionString=$IPA_VER CFBundleVersion=$IPA_BUILD" &&
        test "$IPA_VER" = "#{version}" || (echo "âŒ IPA ç‰ˆæœ¬ä¸ç¬¦ã€‚é æœŸ #{version}ï¼Œå¯¦éš› $IPA_VER" ; exit 1) &&
        test "$IPA_BUILD" = "#{build_number}" || (echo "âŒ IPA build è™Ÿä¸ç¬¦ã€‚é æœŸ #{build_number}ï¼Œå¯¦éš› $IPA_BUILD" ; exit 1)
      }
      UI.success("âœ… IPA ç‰ˆæœ¬é©—è­‰é€šé")
    rescue => e
      UI.user_error!("âŒ IPA ç‰ˆæœ¬é©—è­‰å¤±æ•—ï¼š#{e.message}")
    end
  end

  # ===== ä¸»è¦ Lanes =====
  desc "Build ipa for App Store distribution"
  lane :build do
    generate_podspec

    api_key = get_api_key

    # è¨ˆç®—ç‰ˆæœ¬è™Ÿ
    current_version = get_version_number(xcodeproj: @project_path, target: TARGET_NAME) rescue "1.0.0"
    desired_version = calculate_next_version(current: current_version)

    UI.message("ğŸ“Œ ç‰ˆæœ¬ç®¡ç†ï¼š#{current_version} â†’ #{desired_version}")

    build_number = update_version_and_build(api_key: api_key, version: desired_version)

    # è¨­å®šç°½ç« 
    keychain = create_temp_keychain
    begin
      import_distribution_cert(
        keychain_path: keychain[:path],
        keychain_password: keychain[:password]
      )

      profile_name = setup_code_signing(api_key: api_key)

      clean_gradle_cache
      build_ipa(
        keychain_path: keychain[:path],
        profile_name: profile_name,
        version: desired_version,
        build_number: build_number
      )

      verify_ipa_version(version: desired_version, build_number: build_number)
    ensure
      UI.message("ğŸ—‘ï¸ æ¸…ç†è‡¨æ™‚ keychain: #{keychain[:name]}")
      delete_keychain(name: keychain[:name])
    end
  end

  desc "Upload to TestFlight with automatic version bump on conflict"
  lane :beta do
    build

    api_key = get_api_key

    begin
      version = get_version_number(xcodeproj: @project_path, target: TARGET_NAME) rescue "unknown"
      UI.message("ğŸš€ ä¸Šå‚³è‡³ TestFlight (ç‰ˆæœ¬ #{version})")

      pilot(
        api_key: api_key,
        ipa: "#{OUTPUT_NAME}.ipa",
        skip_waiting_for_build_processing: false
      )
    rescue => ex
      if ex.message =~ /(Invalid Pre-Release Train|CFBundleShortVersionString|already been used|409)/
        UI.important("â›½ï¸ åµæ¸¬åˆ°ç‰ˆæœ¬è¡çªï¼Œè‡ªå‹• bump ä¸¦é‡è©¦")

        current_ver = get_version_number(xcodeproj: @project_path, target: TARGET_NAME) rescue "1.0.0"
        new_ver = calculate_next_version(current: current_ver)

        UI.message("ğŸ“Œ ç‰ˆæœ¬æ›´æ–°ï¼š#{current_ver} â†’ #{new_ver}")

        build_number = update_version_and_build(api_key: api_key, version: new_ver)

        # é‡å»º
        clean_gradle_cache
        generate_podspec

        keychain = create_temp_keychain(name: "fastlane_manual_tmp_retry")
        begin
          import_distribution_cert(
            keychain_path: keychain[:path],
            keychain_password: keychain[:password],
            filename: "dist_cert_retry.p12"
          )

          profile_name = lane_context[SharedValues::SIGH_NAME]
          build_ipa(
            keychain_path: keychain[:path],
            profile_name: profile_name,
            version: new_ver,
            build_number: build_number
          )

          UI.message("ğŸš€ é‡æ–°ä¸Šå‚³æ–°ç‰ˆæœ¬ #{new_ver}")
          pilot(
            api_key: api_key,
            ipa: "#{OUTPUT_NAME}.ipa",
            skip_waiting_for_build_processing: false
          )
        ensure
          delete_keychain(name: keychain[:name])
        end
      else
        raise ex
      end
    end
  end

  desc "Upload to App Store Connect"
  lane :release do
    build

    api_key = get_api_key

    # è®€å–ç’°å¢ƒè®Šæ•¸
    submit = ENV["SUBMIT_FOR_REVIEW"] == "true"
    auto_release = ENV["AUTOMATIC_RELEASE"] == "true"

    # Export Compliance
    uses_encryption = ENV["EXPORT_COMPLIANCE_USES_ENCRYPTION"] == "true"
    submission_info = { export_compliance_uses_encryption: uses_encryption }

    if uses_encryption
      submission_info.merge!(
        export_compliance_is_exempt: ENV["EXPORT_COMPLIANCE_IS_EXEMPT"] == "true",
        export_compliance_contains_third_party_cryptography: ENV["EXPORT_COMPLIANCE_THIRD_PARTY"] == "true",
        export_compliance_contains_proprietary_cryptography: ENV["EXPORT_COMPLIANCE_PROPRIETARY"] == "true"
      )
      if ENV.key?("EXPORT_COMPLIANCE_AVAILABLE_ON_FRENCH_STORE")
        submission_info[:export_compliance_available_on_french_store] = ENV["EXPORT_COMPLIANCE_AVAILABLE_ON_FRENCH_STORE"] == "true"
      end
    end

    begin
      deliver(
        api_key: api_key,
        ipa: "#{OUTPUT_NAME}.ipa",
        submit_for_review: submit,
        automatic_release: auto_release,
        submission_information: submission_info,
        skip_metadata: true,
        skip_screenshots: true,
        force: true,
        precheck_include_in_app_purchases: false,
        run_precheck_before_submit: true
      )
    rescue => ex
      if ex.message.include?("A relationship value is not acceptable for the current resource state")
        UI.important("Build å°šæœªå°±ç·’ï¼Œç­‰å¾… 5 åˆ†é˜å¾Œé‡è©¦")
        sleep(300)
        deliver(
          api_key: api_key,
          submit_for_review: submit,
          automatic_release: auto_release,
          submission_information: submission_info,
          skip_binary_upload: true,
          skip_metadata: true,
          skip_screenshots: true,
          force: true,
          precheck_include_in_app_purchases: false,
          run_precheck_before_submit: true
        )
      else
        raise ex
      end
    end
  end
end