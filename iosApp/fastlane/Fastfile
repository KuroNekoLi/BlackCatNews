require "securerandom"
require "base64"

default_platform(:ios)

platform :ios do
  
  desc "Build ipa for App Store distribution"
  lane :build do
    # åƒ…ä½¿ç”¨ App Store Connect API Keyï¼ˆä¸ä½¿ç”¨ Apple ID è·¯å¾‘ï¼‰
    unless ENV["ASC_KEY_ID"] && ENV["ASC_ISSUER_ID"] && ENV["ASC_PRIVATE_KEY"]
      UI.user_error!("ç¼ºå°‘ App Store Connect API é‡‘é‘°è¨­å®šï¼šè«‹æä¾› ASC_KEY_IDã€ASC_ISSUER_IDã€ASC_PRIVATE_KEY")
    end
    puts "ğŸ”‘ ä½¿ç”¨ App Store Connect API Key èªè­‰"
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_PRIVATE_KEY"],
      is_key_content_base64: ENV["ASC_PRIVATE_KEY_BASE64"] == "true"
    )

    # ä½¿ç”¨æ‰‹å‹•ç°½ç« ï¼ˆåŒ¯å…¥ p12 åˆ°è‡¨æ™‚ keychain + ä¸‹è¼‰ App Store æè¿°æª”ï¼‰
    keychain_name = "fastlane_tmp_keychain"
    keychain_password = SecureRandom.uuid
    puts "ğŸ” å‰µå»ºè‡¨æ™‚ keychain: #{keychain_name}"
    keychain_path = File.expand_path("~/Library/Keychains/#{keychain_name}-db")
    create_keychain(
      name: keychain_name,
      password: keychain_password,
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )
    keychain_candidates = [
      File.expand_path("~/Library/Keychains/#{keychain_name}-db"),
      File.expand_path("~/Library/Keychains/#{keychain_name}.keychain-db"),
      File.expand_path("~/Library/Keychains/#{keychain_name}.keychain")
    ]
    detected_path = keychain_candidates.find { |p| File.exist?(p) }
    keychain_path = detected_path || keychain_path

    unless (ENV["IOS_DIST_CERT_BASE64"] || ENV["IOS_DIST_CERT_PATH"]) && ENV["IOS_DIST_CERT_PASSWORD"]
      UI.user_error!("ç¼ºå°‘ç™¼è¡Œæ†‘è­‰ï¼ˆp12ï¼‰è¨­å®šï¼šè«‹æä¾› IOS_DIST_CERT_BASE64ï¼ˆæˆ– IOS_DIST_CERT_PATHï¼‰èˆ‡ IOS_DIST_CERT_PASSWORD")
    end
    cert_path = ENV["IOS_DIST_CERT_PATH"]
    if cert_path.nil? || cert_path.empty?
      cert_path = File.join(Dir.pwd, "dist_cert.p12")
      File.binwrite(cert_path, Base64.decode64(ENV["IOS_DIST_CERT_BASE64"]))
    end
    cert_password = ENV["IOS_DIST_CERT_PASSWORD"]
    puts "ğŸ” åŒ¯å…¥ Distribution æ†‘è­‰åˆ°è‡¨æ™‚ keychain"
    import_certificate(
      certificate_path: cert_path,
      certificate_password: cert_password,
      keychain_path: keychain_path,
      keychain_password: keychain_password
    )

    sigh(
      api_key: api_key,
      app_identifier: "com.linli.blackcatnews",
      force: true
    )
    profile_uuid = lane_context[SharedValues::SIGH_UUID]
    profile_name = lane_context[SharedValues::SIGH_NAME]
    puts "ğŸ“‹ ä½¿ç”¨æè¿°æª”: #{profile_name} (#{profile_uuid})"

    export_opts = {
      method: "app-store",
      signingStyle: "manual",
      provisioningProfiles: {
        "com.linli.blackcatnews" => profile_uuid
      }
    }
    xcargs = [
      "-allowProvisioningUpdates",
      "CODE_SIGN_STYLE=Manual",
      "CODE_SIGN_IDENTITY='iPhone Distribution'",
      "PROVISIONING_PROFILE=#{profile_uuid}",
      "OTHER_CODE_SIGN_FLAGS='--keychain #{keychain_path}'"
    ].join(" ")

    gym(
      workspace: "iosApp.xcworkspace",
      scheme: "iosApp",
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      include_bitcode: false,
      export_options: export_opts,
      xcargs: xcargs,
      output_directory: ".",
      output_name: "BlackCatNews"
    )

    # æ¸…ç†è‡¨æ™‚ keychain
    puts "ğŸ—‘ï¸ åˆªé™¤è‡¨æ™‚ keychain: #{keychain_name}"
    delete_keychain(name: keychain_name)
  end

  desc "Upload to TestFlight"
  lane :beta do
    build
    
    # åƒ…ä½¿ç”¨ API Key ä¸Šå‚³ TestFlight
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_PRIVATE_KEY"],
      is_key_content_base64: ENV["ASC_PRIVATE_KEY_BASE64"] == "true"
    )
    pilot(
      api_key: api_key,
      ipa: "BlackCatNews.ipa",
      skip_waiting_for_build_processing: false
    )
  end

  desc "Upload to App Store Connect (ä¸è‡ªå‹•é€å¯©)"
  lane :release do
    build
    
    # è®€å–ç’°å¢ƒè®Šæ•¸æ§åˆ¶é€å¯©èˆ‡ä¸Šæ¶
    submit_for_review = ENV["SUBMIT_FOR_REVIEW"] == "true"
    automatic_release = ENV["AUTOMATIC_RELEASE"] == "true"
    
    # å‡ºå£åˆè¦è³‡è¨Šï¼ˆExport Complianceï¼‰
    # é è¨­å‡è¨­æœªä½¿ç”¨éœ€ç”³å ±çš„åŠ å¯†ï¼ˆå¤§å¤šæ•¸åƒ…ä½¿ç”¨ HTTPS çš„ app å¯è¨­ç‚º falseï¼‰
    # å¯ç”¨ç’°å¢ƒè®Šæ•¸è¦†å¯«ï¼š
    #   EXPORT_COMPLIANCE_USES_ENCRYPTION, EXPORT_COMPLIANCE_IS_EXEMPT,
    #   EXPORT_COMPLIANCE_THIRD_PARTY, EXPORT_COMPLIANCE_PROPRIETARY,
    #   EXPORT_COMPLIANCE_AVAILABLE_ON_FRENCH_STORE
    uses_encryption = (ENV["EXPORT_COMPLIANCE_USES_ENCRYPTION"] || "false") == "true"
    submission_info = { export_compliance_uses_encryption: uses_encryption }
    if uses_encryption
      submission_info[:export_compliance_is_exempt] = ENV["EXPORT_COMPLIANCE_IS_EXEMPT"] == "true"
      submission_info[:export_compliance_contains_third_party_cryptography] = ENV["EXPORT_COMPLIANCE_THIRD_PARTY"] == "true"
      submission_info[:export_compliance_contains_proprietary_cryptography] = ENV["EXPORT_COMPLIANCE_PROPRIETARY"] == "true"
      if ENV.key?("EXPORT_COMPLIANCE_AVAILABLE_ON_FRENCH_STORE")
        submission_info[:export_compliance_available_on_french_store] = ENV["EXPORT_COMPLIANCE_AVAILABLE_ON_FRENCH_STORE"] == "true"
      end
    end

    # åƒ…ä½¿ç”¨ API Key ä¸Šå‚³ä¸¦ï¼ˆå¯é¸ï¼‰é€å¯©
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_PRIVATE_KEY"],
      is_key_content_base64: ENV["ASC_PRIVATE_KEY_BASE64"] == "true"
    )
    deliver(
      api_key: api_key,
      ipa: "BlackCatNews.ipa",
      submit_for_review: submit_for_review,
      automatic_release: automatic_release,
      submission_information: submission_info,
      skip_metadata: true,
      skip_screenshots: true,
      force: true,
      precheck_include_in_app_purchases: false,
      run_precheck_before_submit: true
    )
  end
end
