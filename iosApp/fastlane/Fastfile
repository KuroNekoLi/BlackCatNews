require "securerandom"
require "base64"

default_platform(:ios)

platform :ios do
  
  desc "Build ipa for App Store distribution"
  lane :build do
    # 檢查是否有 App Store Connect API Key
    api_key = nil
    if ENV["ASC_KEY_ID"] && ENV["ASC_ISSUER_ID"] && ENV["ASC_PRIVATE_KEY"]
      puts "🔑 使用 App Store Connect API Key 認證"
      api_key = app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: ENV["ASC_PRIVATE_KEY"],
        is_key_content_base64: ENV["ASC_PRIVATE_KEY_BASE64"] == "true"
      )
    else
      puts "🔑 使用 Apple ID + Session 認證"
      if ENV["FASTLANE_USER"].nil? || ENV["FASTLANE_SESSION"].nil?
        UI.user_error!("請設定 FASTLANE_USER 和 FASTLANE_SESSION 環境變數")
      end
    end

    # 在 CI 環境中使用手動簽章
    if ENV["CI"] || ENV["GITHUB_ACTIONS"]
      puts "📱 CI 環境：使用手動簽章"
      
      if api_key.nil?
        UI.user_error!("CI 環境需要 App Store Connect API Key")
      end
      
      # 創建臨時 keychain 以避免簽章卡住
      keychain_name = "fastlane_tmp_keychain"
      keychain_password = SecureRandom.uuid
      
      puts "🔐 創建臨時 keychain: #{keychain_name}"
      
      # 預設一條絕對路徑（稍後會偵測實際存在的檔案）
      keychain_path = File.expand_path("~/Library/Keychains/#{keychain_name}-db")
      
      create_keychain(
        name: keychain_name,
        password: keychain_password,
        default_keychain: true,
        unlock: true,
        timeout: 3600,  # 1 小時後自動鎖定
        lock_when_sleeps: false
      )
      
      # 嘗試偵測實際建立的 keychain 檔案名稱（不同 macOS 可能為 -db、.keychain-db 或 .keychain）
      keychain_candidates = [
        File.expand_path("~/Library/Keychains/#{keychain_name}-db"),
        File.expand_path("~/Library/Keychains/#{keychain_name}.keychain-db"),
        File.expand_path("~/Library/Keychains/#{keychain_name}.keychain")
      ]
      detected_path = keychain_candidates.find { |p| File.exist?(p) }
      keychain_path = detected_path || keychain_path
      
      # 優先從 CI Secrets 匯入既有 Distribution 憑證（避免觸發建立新憑證而達到上限）
      certificate_imported = false
      if ENV["IOS_DIST_CERT_BASE64"] || ENV["IOS_DIST_CERT_PATH"]
        cert_path = ENV["IOS_DIST_CERT_PATH"]
        if cert_path.nil? || cert_path.empty?
          cert_path = File.join(Dir.pwd, "dist_cert.p12")
          File.binwrite(cert_path, Base64.decode64(ENV["IOS_DIST_CERT_BASE64"]))
        end
        cert_password = ENV["IOS_DIST_CERT_PASSWORD"] || ""
        puts "🔏 匯入 Distribution 憑證到臨時 keychain"
        import_certificate(
          certificate_path: cert_path,
          certificate_password: cert_password,
          keychain_path: keychain_path,
          keychain_password: keychain_password
        )
        certificate_imported = true
      end

      unless certificate_imported
        UI.user_error!(
          "CI 未提供 Distribution 憑證（p12）。請於 GitHub Secrets 設定 IOS_DIST_CERT_BASE64 與 IOS_DIST_CERT_PASSWORD，" \
          + "或改用 fastlane match 來安裝簽章憑證與描述檔。"
        )
      end

      # 使用 sigh 下載 App Store 描述檔
      sigh_result = sigh(
        api_key: api_key,
        app_identifier: "com.linli.blackcatnews",
        force: true
      )
      
      # 從 sigh 結果獲取描述檔 UUID
      profile_uuid = lane_context[SharedValues::SIGH_UUID]
      profile_name = lane_context[SharedValues::SIGH_NAME]
      cert_id = lane_context[SharedValues::CERT_CERTIFICATE_ID]
      
      puts "📋 使用描述檔: #{profile_name} (#{profile_uuid})"
      puts "🔐 使用憑證: #{cert_id}"
      
      # 手動簽章設定 - 使用 UUID
      export_opts = {
        method: "app-store",
        signingStyle: "manual",
        provisioningProfiles: {
          "com.linli.blackcatnews" => profile_uuid
        }
      }
      
      # 強制覆蓋 Xcode 專案設定的 xcargs - 注意引號的正確使用
      xcargs = [
        "-allowProvisioningUpdates",
        "CODE_SIGN_STYLE=Manual",
        "CODE_SIGN_IDENTITY='iPhone Distribution'",
        "PROVISIONING_PROFILE=#{profile_uuid}",
        "DEVELOPMENT_TEAM=",
        "OTHER_CODE_SIGN_FLAGS='--keychain #{keychain_path}'"  # 指定使用的 keychain
      ].join(" ")
    else
      puts "🖥️ 本機環境：使用 Xcode 自動簽章"
      export_opts = {
        signingStyle: "automatic"
      }
      
      # 如果有設定 Team ID，加入到 export options
      team_id = ENV["APPLE_TEAM_ID"] || ENV["FASTLANE_TEAM_ID"]
      export_opts[:teamID] = team_id if team_id && !team_id.empty?
      
      xcargs = ""
      keychain_name = nil
    end

    gym(
      workspace: "iosApp.xcworkspace",
      scheme: "iosApp",
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      include_bitcode: false,
      export_options: export_opts,
      xcargs: xcargs,
      output_directory: ".",
      output_name: "BlackCatNews"
    )
    
    # CI 環境：清理臨時 keychain
    if (ENV["CI"] || ENV["GITHUB_ACTIONS"]) && keychain_name
      puts "🗑️ 刪除臨時 keychain: #{keychain_name}"
      delete_keychain(name: keychain_name)
    end
  end

  desc "Upload to TestFlight"
  lane :beta do
    build
    
    # 檢查是否有 API Key
    if ENV["ASC_KEY_ID"] && ENV["ASC_ISSUER_ID"] && ENV["ASC_PRIVATE_KEY"]
      api_key = app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: ENV["ASC_PRIVATE_KEY"],
        is_key_content_base64: ENV["ASC_PRIVATE_KEY_BASE64"] == "true"
      )
      
      pilot(
        api_key: api_key,
        ipa: "BlackCatNews.ipa",
        skip_waiting_for_build_processing: false
      )
    else
      # 使用 Apple ID 路徑
      pilot(
        ipa: "BlackCatNews.ipa",
        skip_waiting_for_build_processing: false
      )
    end
  end

  desc "Upload to App Store Connect (不自動送審)"
  lane :release do
    build
    
    # 讀取環境變數控制送審與上架
    submit_for_review = ENV["SUBMIT_FOR_REVIEW"] == "true"
    automatic_release = ENV["AUTOMATIC_RELEASE"] == "true"
    
    # 檢查是否有 API Key
    if ENV["ASC_KEY_ID"] && ENV["ASC_ISSUER_ID"] && ENV["ASC_PRIVATE_KEY"]
      api_key = app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: ENV["ASC_PRIVATE_KEY"],
        is_key_content_base64: ENV["ASC_PRIVATE_KEY_BASE64"] == "true"
      )
      
      deliver(
        api_key: api_key,
        ipa: "BlackCatNews.ipa",
        submit_for_review: submit_for_review,
        automatic_release: automatic_release,
        skip_metadata: true,
        skip_screenshots: true,
        force: true
      )
    else
      # 使用 Apple ID 路徑
      deliver(
        ipa: "BlackCatNews.ipa",
        submit_for_review: submit_for_review,
        automatic_release: automatic_release,
        skip_metadata: true,
        skip_screenshots: true,
        force: true
      )
    end
  end

end
