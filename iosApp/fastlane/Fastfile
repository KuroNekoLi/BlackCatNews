require "securerandom"
require "base64"
require "spaceship"

default_platform(:ios)

platform :ios do

  desc "Build ipa for App Store distribution"
  lane :build do
    # Resolve absolute paths to avoid running Gradle from iosApp/fastlane
    root_dir = File.expand_path('../..', __dir__)         # repo root
    gradlew  = File.join(root_dir, 'gradlew')             # wrapper at repo root
    ios_proj_dir = File.expand_path('..', __dir__)        # iosApp directory

    # ğŸ”§ [æ–°å¢æ­¥é©Ÿ 1] å…ˆç”Ÿæˆ composeApp çš„ podspec èˆ‡ dummy frameworks
    sh %Q{#{gradlew} -p "#{root_dir}" :composeApp:podspec :core:authentication:podspec :composeApp:generateDummyFramework :core:authentication:generateDummyFramework --no-daemon --stacktrace}, log: true

    # ğŸ”§å¾ Fastlane çš„ç›¸å°å±¤åŸ·è¡Œ pod install
    sh %Q{bundle exec pod install --project-directory="#{ios_proj_dir}" --repo-update}, log: true

    # åƒ…ä½¿ç”¨ App Store Connect API Keyï¼ˆä¸ä½¿ç”¨ Apple ID è·¯å¾‘ï¼‰
    unless ENV["ASC_KEY_ID"] && ENV["ASC_ISSUER_ID"] && (ENV["ASC_PRIVATE_KEY"] || ENV["ASC_PRIVATE_KEY_BASE64"])
      UI.user_error!("ç¼ºå°‘ App Store Connect API é‡‘é‘°è¨­å®šï¼šè«‹æä¾› ASC_KEY_IDã€ASC_ISSUER_IDã€ASC_PRIVATE_KEY")
    end
    puts "ğŸ”‘ ä½¿ç”¨ App Store Connect API Key èªè­‰"
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty? ? ENV["ASC_PRIVATE_KEY"] : ENV["ASC_PRIVATE_KEY_BASE64"],
      is_key_content_base64: !ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty?
    )

    # ===== Auto-manage MARKETING_VERSION (CFBundleShortVersionString) and CFBundleVersion =====
    # Prefer xcconfig as the source of truth, fallback to xcodeproj if needed
    project_path  = File.expand_path('../iosApp.xcodeproj', __dir__)
    workspace_path = File.expand_path('../iosApp.xcworkspace', __dir__)
    xcconfig_path = File.expand_path('../Configuration/Config.xcconfig', __dir__)

    def parse_ver(v)
      v.to_s.strip.split('.').map(&:to_i)
    end
    def cmp_ver(a, b)
      ax = parse_ver(a); bx = parse_ver(b)
      (0..2).each do |i|
        (ax[i] ||= 0); (bx[i] ||= 0)
        return ax[i] <=> bx[i] if ax[i] != bx[i]
      end
      0
    end
    def bump_patch(v)
      a = parse_ver(v)
      a[0] ||= 1; a[1] ||= 0; a[2] ||= 0
      a[2] += 1
      "%d.%d.%d" % a[0..2]
    end

    current_from_proj = (get_version_number(xcodeproj: project_path, target: "iosApp") rescue nil)
    base_version = current_from_proj || "1.0.0"

    # If triggered by tag like ios-vX.Y.Z or ios-beta-vX.Y.Z, respect tag version; else bump patch
    ref_type = ENV['GITHUB_REF_TYPE'].to_s
    ref_name = ENV['GITHUB_REF_NAME'].to_s
    desired_version = nil
    if ref_type == 'tag' && ref_name =~ /^ios-(?:beta-)?v(\d+\.\d+\.\d+)$/
      desired_version = Regexp.last_match(1)
    else
      desired_version = bump_patch(base_version)
    end

    # ğŸ” åŒæ­¥æª¢æŸ¥ App Store å·²æ ¸æº–çš„ç‰ˆæœ¬ï¼ˆlive ç‰ˆï¼‰- ä½¿ç”¨æ­£ç¢ºçš„ Token å»ºç«‹æ–¹å¼
    begin
      require 'spaceship'
      # ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨ Token.create è€Œé from_api_key
      token = Spaceship::ConnectAPI::Token.create(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key: ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty? ? ENV["ASC_PRIVATE_KEY"] : ENV["ASC_PRIVATE_KEY_BASE64"],
        is_key_content_base64: !ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty?
      )
      Spaceship::ConnectAPI.token = token
      app = Spaceship::ConnectAPI::App.find('com.linli.blackcatnews')
      live = app.get_live_app_store_version
      approved_version = live&.version_string
      if approved_version && cmp_ver(desired_version, approved_version) <= 0
        UI.important("âš ï¸ Current approved App Store version is #{approved_version}; bumping above it.")
        desired_version = bump_patch(approved_version)
      end
    rescue => e
      UI.important("âš ï¸ Unable to query live App Store version: #{e.message} â€” will proceed with desired_version=#{desired_version}")
    end

    # ç¢ºä¿ä»ç„¶ >= å°ˆæ¡ˆä¸­çš„ç‰ˆæœ¬
    desired_version = bump_patch(base_version) if cmp_ver(desired_version, base_version) <= 0

    UI.message("ğŸ“Œ MARKETING_VERSION: base=#{base_version} â†’ set to #{desired_version}")
    UI.message("ğŸ“Œ MARKETING_VERSION will be set to #{desired_version} at build time only (not writing to Config.xcconfig)")

    # Also sync xcodeproj marketing version for consistency (xcconfig remains source of truth)
    begin
      increment_version_number(
        xcodeproj: project_path,
        version_number: desired_version
      )
    rescue => e
      UI.important("âš ï¸ Could not update xcodeproj MARKETING_VERSION: #{e.message}. Proceeding with xcconfig value.")
    end

    # Compute CFBundleVersion from TestFlight latest build for this marketing version (only increases when actually uploading)
    begin
      latest_tf_build = latest_testflight_build_number(
        app_identifier: 'com.linli.blackcatnews',
        version: desired_version,
        api_key: api_key
      )
      next_build = latest_tf_build.to_i + 1
      UI.message("ğŸ”¢ Set CFBundleVersion to #{next_build} (latest TestFlight build for #{desired_version} was #{latest_tf_build})")

      # Update CFBundleVersion (CURRENT_PROJECT_VERSION) directly in the Xcode project
      increment_build_number(build_number: next_build, xcodeproj: project_path)
    rescue => e
      UI.important("âš ï¸ Could not fetch latest TestFlight build: #{e.message}. Fallback CFBundleVersion=1")
      increment_build_number(build_number: 1, xcodeproj: project_path)
    end
    # ===== End auto-manage versioning =====

    begin
      # ä½¿ç”¨æ‰‹å‹•ç°½ç« ï¼ˆåŒ¯å…¥ p12 åˆ°è‡¨æ™‚ keychain + ä¸‹è¼‰ App Store æè¿°æª”ï¼‰
      keychain_name = "fastlane_manual_tmp"
      keychain_password = SecureRandom.uuid
      puts "ğŸ” å‰µå»ºè‡¨æ™‚ keychain: #{keychain_name}"
      keychain_path = File.expand_path("~/Library/Keychains/#{keychain_name}-db")
      create_keychain(
        name: keychain_name,
        password: keychain_password,
        default_keychain: true,
        unlock: true,
        timeout: 3600,
        lock_when_sleeps: false,
        require_create: true
      )

      unless (ENV["IOS_DIST_CERT_BASE64"] || ENV["IOS_DIST_CERT_PATH"]) && ENV["IOS_DIST_CERT_PASSWORD"]
        UI.user_error!("ç¼ºå°‘ç™¼è¡Œæ†‘è­‰ï¼ˆp12ï¼‰è¨­å®šï¼šè«‹æä¾› IOS_DIST_CERT_BASE64ï¼ˆæˆ– IOS_DIST_CERT_PATHï¼‰èˆ‡ IOS_DIST_CERT_PASSWORD")
      end
      cert_path = ENV["IOS_DIST_CERT_PATH"]
      if cert_path.nil? || cert_path.empty?
        cert_path = File.join(Dir.pwd, "dist_cert.p12")
        File.binwrite(cert_path, Base64.decode64(ENV["IOS_DIST_CERT_BASE64"]))
      end
      cert_password = ENV["IOS_DIST_CERT_PASSWORD"]
      puts "ğŸ” åŒ¯å…¥ Distribution æ†‘è­‰åˆ°è‡¨æ™‚ keychain"
      import_certificate(
        certificate_path: cert_path,
        certificate_password: cert_password,
        keychain_path: keychain_path,
        keychain_password: keychain_password
      )

      sigh(
        api_key: api_key,
        app_identifier: "com.linli.blackcatnews",
        force: true
      )
      profile_uuid = lane_context[SharedValues::SIGH_UUID]
      profile_name = lane_context[SharedValues::SIGH_NAME]
      puts "ğŸ“‹ ä½¿ç”¨æè¿°æª”: #{profile_name} (#{profile_uuid})"

      # å°‡ iosApp ä¸» target çš„ Release è¨­ç‚ºæ‰‹å‹•ç°½ç« ï¼ˆé¿å… CI éœ€è¦ Apple ID/Development Profileï¼‰
      update_code_signing_settings(
        use_automatic_signing: false,
        path: File.expand_path('../iosApp.xcodeproj', __dir__),
        targets: ["iosApp"],
        build_configurations: ["Release"],
        team_id: ENV["APPLE_TEAM_ID"],
        code_sign_identity: "Apple Distribution",
        profile_name: profile_name
      )

      export_opts = {
        method: "app-store",
        signingStyle: "manual",
        provisioningProfiles: {
          "com.linli.blackcatnews" => profile_name
        }
      }
      xcargs = [
        "-allowProvisioningUpdates",
        "OTHER_CODE_SIGN_FLAGS='--keychain #{keychain_path}'",
        "MARKETING_VERSION=#{desired_version}",
        "CURRENT_PROJECT_VERSION=#{next_build}",
        "-jobs 1"
      ].join(" ")

      sh %Q{#{gradlew} --stop || true}
      sh %Q{rm -rf "#{root_dir}/.gradle/configuration-cache"}

      gym(
        workspace: File.expand_path('../iosApp.xcworkspace', __dir__),
        scheme: "iosApp",
        configuration: "Release",
        export_method: "app-store",
        clean: true,
        include_bitcode: false,
        export_options: export_opts,
        xcargs: xcargs,
        output_directory: File.expand_path('..', __dir__),
        output_name: "BlackCatNews"
      )
      # âœ… Verify version embedded in IPA matches what we set
      begin
        ipa_path = File.expand_path('..', __dir__) + "/BlackCatNews.ipa"
        sh %Q{
          tmpdir=$(mktemp -d) &&
          unzip -q "#{ipa_path}" -d "$tmpdir" &&
          IPA_VER=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$tmpdir/Payload/BlackCatNews.app/Info.plist") &&
          IPA_BUILD=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$tmpdir/Payload/BlackCatNews.app/Info.plist") &&
          echo "ğŸ“¦ IPA CFBundleShortVersionString=$IPA_VER CFBundleVersion=$IPA_BUILD" &&
          test "$IPA_VER" = "#{desired_version}" || (echo "âŒ IPA version mismatch. expected #{desired_version}, got $IPA_VER" ; exit 1) &&
          test "$IPA_BUILD" = "#{next_build}" || (echo "âŒ IPA build mismatch. expected #{next_build}, got $IPA_BUILD" ; exit 1)
        }
      rescue => e
        UI.user_error!("IPA version verification failed: #{e.message}")
      end
    ensure
      puts "ğŸ—‘ï¸ åˆªé™¤è‡¨æ™‚ keychain: #{keychain_name}"
      delete_keychain(name: keychain_name)
    end
  end

  desc "Upload to TestFlight with automatic version bump on Invalid Pre-Release Train"
  lane :beta do
    build

    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty? ? ENV["ASC_PRIVATE_KEY"] : ENV["ASC_PRIVATE_KEY_BASE64"],
      is_key_content_base64: !ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty?
    )

    workspace_path = File.expand_path('../iosApp.xcworkspace', __dir__)
    project_path   = File.expand_path('../iosApp.xcodeproj', __dir__)
    xcconfig_path  = File.expand_path('../Configuration/Config.xcconfig', __dir__)
    gradlew        = File.join(File.expand_path('../..', __dir__), 'gradlew')
    repo_root      = File.expand_path('../..', __dir__)

    begin
      # ç¬¬ä¸€æ¬¡å˜—è©¦ä¸Šå‚³
       version = (Actions.lane_context[SharedValues::VERSION_NUMBER] rescue nil) || ENV["MARKETING_VERSION"] || "unknown"
       UI.message("ğŸ” å˜—è©¦ä¸Šå‚³ç‰ˆæœ¬ #{version} â€¦")
      pilot(
        api_key: api_key,
        ipa: "BlackCatNews.ipa",
        skip_waiting_for_build_processing: false
      )
    rescue => ex  # ğŸ”§ ä¿®æ­£ï¼šæ”¹ç‚ºæ•ç²æ‰€æœ‰ä¾‹å¤–
      msg = ex.message.to_s
      if msg =~ /(Invalid Pre-Release Train|CFBundleShortVersionString|already been used|409)/
        UI.important("â›½ï¸ è‡ªå‹•è£œæ•‘ï¼šåµæ¸¬åˆ°ç‰ˆæœ¬åˆ—è»Šé—œé–‰æˆ–ç‰ˆæœ¬è™Ÿç›¸åŒï¼Œå°‡è‡ªå‹• bump patch ä¸¦é‡å»ºä¸Šå‚³")

        # ---- è®€å–ç›®å‰ç‰ˆæœ¬ä¸¦ +0.0.1 ----
        def parse_ver(v)
          v.to_s.strip.split('.').map(&:to_i)
        end
        def bump_patch(v)
          a = parse_ver(v)
          a[0] ||= 1; a[1] ||= 0; a[2] ||= 0
          a[2] += 1
          "%d.%d.%d" % a[0..2]
        end
        def cmp_ver(a, b)
          ax = parse_ver(a); bx = parse_ver(b)
          (0..2).each do |i|
            (ax[i] ||= 0); (bx[i] ||= 0)
            return ax[i] <=> bx[i] if ax[i] != bx[i]
          end
          0
        end

         current_ver = (
           get_version_number(xcodeproj: project_path, target: "iosApp") rescue
           (Actions.lane_context[SharedValues::VERSION_NUMBER] rescue "1.0.0")
         )
        new_ver = bump_patch(current_ver)

        # ğŸ” æª¢æŸ¥ App Store å·²æ ¸å‡†ç‰ˆæœ¬ï¼Œç¢ºä¿æ–°ç‰ˆæœ¬é«˜æ–¼å®ƒ - ä½¿ç”¨æ­£ç¢ºçš„ Token å»ºç«‹æ–¹å¼
        begin
          require 'spaceship'
          # ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨ Token.create è€Œé from_api_key
          token = Spaceship::ConnectAPI::Token.create(
            key_id: ENV["ASC_KEY_ID"],
            issuer_id: ENV["ASC_ISSUER_ID"],
            key: ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty? ? ENV["ASC_PRIVATE_KEY"] : ENV["ASC_PRIVATE_KEY_BASE64"],
            is_key_content_base64: !ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty?
          )
          Spaceship::ConnectAPI.token = token
          app = Spaceship::ConnectAPI::App.find('com.linli.blackcatnews')
          live = app.get_live_app_store_version
          approved_version = live&.version_string
          if approved_version && cmp_ver(new_ver, approved_version) <= 0
            UI.important("âš ï¸ App Store å·²æ ¸å‡†ç‰ˆæœ¬ç‚º #{approved_version}ï¼Œå¿…é ˆé«˜æ–¼æ­¤ç‰ˆæœ¬")
            new_ver = bump_patch(approved_version)
            UI.message("ğŸ“Œ èª¿æ•´ç‚º #{new_ver}")
          end
        rescue => e
          UI.important("âš ï¸ ç„¡æ³•æŸ¥è©¢ App Store ç‰ˆæœ¬ï¼š#{e.message}")
        end

        UI.message("ğŸ“Œ å°‡ MARKETING_VERSION å¾ #{current_ver} â†’ #{new_ver}")

        # æ›´æ–° xcconfig ç‚ºçœŸå¯¦ä¾†æºï¼Œå†åŒæ­¥åˆ° xcodeproj
        UI.message("ğŸ“Œ MARKETING_VERSION will be set to #{new_ver} at build time only (not writing to Config.xcconfig)")
        begin
          increment_version_number(xcodeproj: project_path, version_number: new_ver)
        rescue => e
          UI.important("âš ï¸ ç„¡æ³•æ›´æ–° xcodeproj MARKETING_VERSIONï¼š#{e.message}ï¼Œä½†ç¹¼çºŒåŸ·è¡Œã€‚")
        end

        # é‡æ–°è¨ˆç®—ä¸¦éå¢ CFBundleVersionï¼ˆä»¥ TestFlight ä¸Šè©²ç‰ˆæœ¬æœ€æ–° build + 1ï¼‰
        begin
          latest_tf_build = latest_testflight_build_number(
            app_identifier: 'com.linli.blackcatnews',
            version: new_ver,
            api_key: api_key
          )
          next_build = latest_tf_build.to_i + 1
          increment_build_number(build_number: next_build, xcodeproj: project_path)
          UI.message("ğŸ”¢ è¨­å®š CFBundleVersion ç‚º #{next_build}")
        rescue => e
          UI.important("âš ï¸ ç„¡æ³•è®€å– TestFlight buildï¼š#{e.message}ï¼Œå›é€€åˆ° build=1")
          increment_build_number(build_number: 1, xcodeproj: project_path)
        end

        # ---- é‡æ–°ç”¢ç”Ÿ podspec / æ¸…ç† Gradle å¿«å– ----
        sh %Q{#{gradlew} --stop || true}
        sh %Q{rm -rf "#{repo_root}/.gradle/configuration-cache"}
        sh %Q{#{gradlew} -p "#{repo_root}" :composeApp:podspec :composeApp:generateDummyFramework --no-daemon --stacktrace}, log: true

        # ---- é‡æ–°å»ºç«‹è‡¨æ™‚ keychain ä¸¦åŒ¯å…¥æ†‘è­‰ï¼ˆå›  build lane å·²æ¸…é™¤ï¼‰----
        keychain_name = "fastlane_manual_tmp_retry"
        keychain_password = SecureRandom.uuid
        create_keychain(
          name: keychain_name,
          password: keychain_password,
          default_keychain: true,
          unlock: true,
          timeout: 3600,
          lock_when_sleeps: false,
          require_create: true
        )
        keychain_path = File.expand_path("~/Library/Keychains/#{keychain_name}-db")

        unless (ENV["IOS_DIST_CERT_BASE64"] || ENV["IOS_DIST_CERT_PATH"]) && ENV["IOS_DIST_CERT_PASSWORD"]
          UI.user_error!("ç¼ºå°‘ç™¼è¡Œæ†‘è­‰ï¼ˆp12ï¼‰è¨­å®šï¼šè«‹æä¾› IOS_DIST_CERT_BASE64ï¼ˆæˆ– IOS_DIST_CERT_PATHï¼‰èˆ‡ IOS_DIST_CERT_PASSWORD")
        end
        cert_path = ENV["IOS_DIST_CERT_PATH"]
        if cert_path.nil? || cert_path.empty?
          cert_path = File.join(Dir.pwd, "dist_cert_retry.p12")
          File.binwrite(cert_path, Base64.decode64(ENV["IOS_DIST_CERT_BASE64"]))
        end
        import_certificate(
          certificate_path: cert_path,
          certificate_password: ENV["IOS_DIST_CERT_PASSWORD"],
          keychain_path: keychain_path,
          keychain_password: keychain_password
        )

        # ä½¿ç”¨å‰ä¸€æ¬¡ sigh ä¸‹è¼‰çš„æè¿°æª”åç¨±
        profile_name = lane_context[SharedValues::SIGH_NAME]

        # ---- é‡æ–°æ‰“åŒ… ipa ----
        gym(
          workspace: workspace_path,
          scheme: "iosApp",
          configuration: "Release",
          export_method: "app-store",
          clean: true,
          include_bitcode: false,
          export_options: {
            method: "app-store",
            signingStyle: "manual",
            provisioningProfiles: { "com.linli.blackcatnews" => profile_name }
          },
          xcargs: "-allowProvisioningUpdates OTHER_CODE_SIGN_FLAGS='--keychain #{keychain_path}' MARKETING_VERSION=#{new_ver} CURRENT_PROJECT_VERSION=#{next_build} -jobs 1",
          output_directory: File.expand_path('..', __dir__),
          output_name: "BlackCatNews"
        )

        # ---- å†æ¬¡ä¸Šå‚³ ----
        UI.message("ğŸš€ é‡æ–°ä¸Šå‚³æ–°ç‰ˆæœ¬ #{new_ver}")
        pilot(
          api_key: api_key,
          ipa: "BlackCatNews.ipa",
          skip_waiting_for_build_processing: false
        )

        # æ¸…ç†è‡¨æ™‚ keychainï¼ˆé‡è©¦ç”¨ï¼‰
        delete_keychain(name: keychain_name)
      else
        raise ex
      end
    end
  end

  desc "Upload to App Store Connect (ä¸è‡ªå‹•é€å¯©)"
  lane :release do
    build

    # è®€å–ç’°å¢ƒè®Šæ•¸æ§åˆ¶é€å¯©èˆ‡ä¸Šæ¶
    submit_for_review = ENV["SUBMIT_FOR_REVIEW"] == "true"
    automatic_release = ENV["AUTOMATIC_RELEASE"] == "true"

    # å‡ºå£åˆè¦è³‡è¨Šï¼ˆExport Complianceï¼‰
    # é è¨­å‡è¨­æœªä½¿ç”¨éœ€ç”³å ±çš„åŠ å¯†ï¼ˆå¤§å¤šæ•¸åƒ…ä½¿ç”¨ HTTPS çš„ app å¯è¨­ç‚º falseï¼‰
    # å¯ç”¨ç’°å¢ƒè®Šæ•¸è¦†å¯«ï¼š
    #   EXPORT_COMPLIANCE_USES_ENCRYPTION, EXPORT_COMPLIANCE_IS_EXEMPT,
    #   EXPORT_COMPLIANCE_THIRD_PARTY, EXPORT_COMPLIANCE_PROPRIETARY,
    #   EXPORT_COMPLIANCE_AVAILABLE_ON_FRENCH_STORE
    uses_encryption = (ENV["EXPORT_COMPLIANCE_USES_ENCRYPTION"] || "false") == "true"
    submission_info = { export_compliance_uses_encryption: uses_encryption }
    if uses_encryption
      submission_info[:export_compliance_is_exempt] = ENV["EXPORT_COMPLIANCE_IS_EXEMPT"] == "true"
      submission_info[:export_compliance_contains_third_party_cryptography] = ENV["EXPORT_COMPLIANCE_THIRD_PARTY"] == "true"
      submission_info[:export_compliance_contains_proprietary_cryptography] = ENV["EXPORT_COMPLIANCE_PROPRIETARY"] == "true"
      if ENV.key?("EXPORT_COMPLIANCE_AVAILABLE_ON_FRENCH_STORE")
        submission_info[:export_compliance_available_on_french_store] = ENV["EXPORT_COMPLIANCE_AVAILABLE_ON_FRENCH_STORE"] == "true"
      end
    end

    # åƒ…ä½¿ç”¨ API Key ä¸Šå‚³ä¸¦ï¼ˆå¯é¸ï¼‰é€å¯©
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty? ? ENV["ASC_PRIVATE_KEY"] : ENV["ASC_PRIVATE_KEY_BASE64"],
      is_key_content_base64: !ENV["ASC_PRIVATE_KEY_BASE64"].to_s.empty?
    )
    begin
      deliver(
        api_key: api_key,
        ipa: "BlackCatNews.ipa",
        submit_for_review: submit_for_review,
        automatic_release: automatic_release,
        submission_information: submission_info,
        skip_metadata: true,
        skip_screenshots: true,
        force: true,
        precheck_include_in_app_purchases: false,
        run_precheck_before_submit: true
      )
    rescue => ex
      if ex.message.include?("A relationship value is not acceptable for the current resource state")
        UI.important("[è‡ªå‹•é‡è©¦] Build å°šæœª ready for submissionï¼Œsleep 5 åˆ†é˜å¾Œå†å˜—è©¦åƒ…é€å¯© submit_for_review")
        sleep(300)
        deliver(
          api_key: api_key,
          submit_for_review: submit_for_review,
          automatic_release: automatic_release,
          submission_information: submission_info,
          skip_binary_upload: true,
          skip_metadata: true,
          skip_screenshots: true,
          force: true,
          precheck_include_in_app_purchases: false,
          run_precheck_before_submit: true
        )
      else
        raise ex
      end
    end
  end
end