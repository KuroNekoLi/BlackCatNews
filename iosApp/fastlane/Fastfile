# Fastfile â€” iOS build / TestFlight / Releaseï¼ˆç²¾ç°¡å¯ç¶­è­·ç‰ˆï¼‰
# éœ€æ±‚ï¼š
#   ENV: ASC_KEY_ID, ASC_ISSUER_ID, ASC_PRIVATE_KEY[, ASC_PRIVATE_KEY_BASE64=true]
#        IOS_DIST_CERT_PASSWORD, (IOS_DIST_CERT_PATH æˆ– IOS_DIST_CERT_BASE64)
#        SUBMIT_FOR_REVIEW, AUTOMATIC_RELEASE, EXPORT_COMPLIANCE_*

require 'securerandom'
require 'base64'
require 'plist'
require 'fileutils'

default_platform(:ios)

# ---- å¾å°ˆæ¡ˆæª”æ¡ˆè®€å–é…ç½® ----
def read_xcconfig(key, default = nil)
  config_file = File.expand_path('../Configuration/Config.xcconfig', __dir__)
  return default unless File.exist?(config_file)
  
  File.readlines(config_file).each do |line|
    # è·³éè¨»é‡‹å’Œç©ºè¡Œ
    next if line.strip.start_with?('//') || line.strip.empty?
    
    # è§£æ KEY=VALUE æ ¼å¼
    if line =~ /^#{key}\s*=\s*(.+)$/
      return $1.strip
    end
  end
  
  default
end

# å°ˆæ¡ˆé…ç½®ï¼ˆå¾ Config.xcconfig å‹•æ…‹è®€å–ï¼‰
APP_IDENTIFIER = read_xcconfig('PRODUCT_BUNDLE_IDENTIFIER', 'com.linli.blackcatnews')
PRODUCT_NAME   = read_xcconfig('PRODUCT_NAME', 'BlackCatNews')
XCODEPROJ      = 'iosApp.xcodeproj'
SCHEME         = 'iosApp'
IPA_NAME       = PRODUCT_NAME

UI.message("ğŸ“± App Identifier: #{APP_IDENTIFIER}")
UI.message("ğŸ“¦ Product Name: #{PRODUCT_NAME}")

# ---- Helpers ----
def fetch_api_key!
  %w[ASC_KEY_ID ASC_ISSUER_ID ASC_PRIVATE_KEY].each do |k|
    UI.user_error!("ç¼ºå°‘ #{k}") if ENV[k].to_s.empty?
  end
  app_store_connect_api_key(
    key_id: ENV['ASC_KEY_ID'],
    issuer_id: ENV['ASC_ISSUER_ID'],
    key_content: ENV['ASC_PRIVATE_KEY'],
    is_key_content_base64: ENV['ASC_PRIVATE_KEY_BASE64'] == 'true'
  )
end

# å–å¾— Team ID ä»¥ä¾› Xcode ç°½ç« 
def extract_team_id(profile_path)
  UI.message("ğŸ” å¾æè¿°æª”æå– Team ID: #{profile_path}")
  
  # æª¢æŸ¥æª”æ¡ˆæ˜¯å¦å­˜åœ¨
  unless File.exist?(profile_path)
    UI.error("æè¿°æª”ä¸å­˜åœ¨: #{profile_path}")
    return nil
  end
  
  # è§£ææè¿°æª”
  profile_content = `security cms -D -i "#{profile_path}"`
  if profile_content.empty?
    UI.error("ç„¡æ³•è®€å–æè¿°æª”å…§å®¹")
    return nil
  end
  
  plist = Plist.parse_xml(profile_content)
  unless plist
    UI.error("ç„¡æ³•è§£ææè¿°æª” plist å…§å®¹")
    return nil
  end
  
  team_id = plist['TeamIdentifier']&.first
  if team_id.nil? || team_id.empty?
    UI.error("æè¿°æª”ä¸­æ‰¾ä¸åˆ° TeamIdentifier")
    return nil
  end
  
  UI.success("âœ… æˆåŠŸæå– Team ID: #{team_id}")
  team_id
end

# åŒ¯å…¥ p12 åˆ°æŒ‡å®š keychain
def import_p12!(keychain_path:, keychain_password:)
  pwd = ENV['IOS_DIST_CERT_PASSWORD']
  UI.user_error!('ç¼ºå°‘ IOS_DIST_CERT_PASSWORD') if pwd.to_s.empty?

  cert_path = ENV['IOS_DIST_CERT_PATH']
  unless cert_path && !cert_path.empty?
    UI.user_error!('ç¼ºå°‘ IOS_DIST_CERT_BASE64 æˆ– IOS_DIST_CERT_PATH') if ENV['IOS_DIST_CERT_BASE64'].to_s.empty?
    cert_path = File.join(Dir.pwd, 'dist_cert.p12')
    File.binwrite(cert_path, Base64.decode64(ENV['IOS_DIST_CERT_BASE64']))
  end

  import_certificate(
    certificate_path: cert_path,
    certificate_password: pwd,
    keychain_path: keychain_path,
    keychain_password: keychain_password
  )
end

# å‡ºå£åˆè¦è³‡è¨Šï¼ˆå¯é¸ï¼‰
def export_compliance_info
  uses = ENV['EXPORT_COMPLIANCE_USES_ENCRYPTION'] == 'true'
  info = { export_compliance_uses_encryption: uses }
  if uses
    info[:export_compliance_is_exempt] = ENV['EXPORT_COMPLIANCE_IS_EXEMPT'] == 'true'
    info[:export_compliance_contains_third_party_cryptography] = ENV['EXPORT_COMPLIANCE_THIRD_PARTY'] == 'true'
    info[:export_compliance_contains_proprietary_cryptography] = ENV['EXPORT_COMPLIANCE_PROPRIETARY'] == 'true'
    info[:export_compliance_available_on_french_store] = ENV['EXPORT_COMPLIANCE_AVAILABLE_ON_FRENCH_STORE'] == 'true' if ENV.key?('EXPORT_COMPLIANCE_AVAILABLE_ON_FRENCH_STORE')
  end
  info
end

# ---- Lanes ----
platform :ios do
  desc 'Build ipaï¼ˆApp Store ç™¼ä½ˆç”¨ï¼‰'
  lane :build do
    UI.message('ğŸ”‘ ä½¿ç”¨ App Store Connect API Key èªè­‰')
    api_key = fetch_api_key!

    keychain_name = 'fastlane_tmp_keychain'
    keychain_password = SecureRandom.uuid

    create_keychain(
      name: keychain_name,
      password: keychain_password,
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    # å˜—è©¦å¹¾ç¨®å¸¸è¦‹çš„ keychain è·¯å¾‘
    candidates = [
      File.expand_path("~/Library/Keychains/#{keychain_name}-db"),
      File.expand_path("~/Library/Keychains/#{keychain_name}.keychain-db"),
      File.expand_path("~/Library/Keychains/#{keychain_name}.keychain")
    ]
    keychain_path = candidates.find { |p| File.exist?(p) } || candidates.first

    UI.message('ğŸ” åŒ¯å…¥ Distribution æ†‘è­‰åˆ°è‡¨æ™‚ keychain')
    import_p12!(keychain_path: keychain_path, keychain_password: keychain_password)

    # ä¸‹è¼‰ä¸¦å®‰è£ App Store æè¿°æª”
    sigh(
      api_key: api_key,
      app_identifier: APP_IDENTIFIER,
      force: true,
      skip_install: false
    )
    
    # å¾ lane_context ä¸­ç²å–æ‰€æœ‰éœ€è¦çš„ä¿¡æ¯
    profile_path = lane_context[SharedValues::SIGH_PROFILE_PATH]
    profile_uuid = lane_context[SharedValues::SIGH_UUID]
    profile_name = lane_context[SharedValues::SIGH_NAME]
    
    UI.success("ğŸ“‹ ä½¿ç”¨æè¿°æª”: #{profile_name} (#{profile_uuid})")
    UI.message("ğŸ“„ æè¿°æª”è·¯å¾‘: #{profile_path}")
    
    # é©—è­‰æè¿°æª”è·¯å¾‘
    if profile_path.nil? || profile_path.empty?
      UI.user_error!("âŒ æè¿°æª”ä¸‹è¼‰å¤±æ•—ï¼šprofile_path ç‚ºç©º")
    end
    
    unless File.exist?(profile_path)
      UI.user_error!("âŒ æè¿°æª”ä¸å­˜åœ¨: #{profile_path}")
    end
    
    UI.success("âœ… æè¿°æª”å·²æˆåŠŸä¸‹è¼‰ä¸¦é©—è­‰")
    
    # æ‰‹å‹•å®‰è£ profile åˆ°ç³»çµ±ç›®éŒ„ï¼ˆCI ç’°å¢ƒå¿…é ˆï¼‰
    system_profile_dir = File.expand_path("~/Library/MobileDevice/Provisioning Profiles")
    FileUtils.mkdir_p(system_profile_dir)
    system_profile_path = File.join(system_profile_dir, "#{profile_uuid}.mobileprovision")
    FileUtils.cp(profile_path, system_profile_path)
    UI.success("âœ… å·²å®‰è£ profile åˆ°ç³»çµ±ç›®éŒ„: #{system_profile_path}")

    # å¾æè¿°æª”è®€å– Team ID
    team_id = extract_team_id(profile_path)
    if team_id.nil? || team_id.empty?
      UI.user_error!("âŒ ç„¡æ³•å¾æè¿°æª”æå– Team IDï¼Œè«‹æª¢æŸ¥æè¿°æª”æ˜¯å¦æœ‰æ•ˆ")
    end
    UI.message("ğŸ¢ Team ID: #{team_id}")

    # Xcode åƒæ•¸ï¼ˆåŒ…å« PROVISIONING_PROFILE_SPECIFIERï¼‰
    xc = [
      "-allowProvisioningUpdates",
      "OTHER_CODE_SIGN_FLAGS='--keychain #{keychain_path}'",
      "DEVELOPMENT_TEAM=#{team_id}",
      "PROVISIONING_PROFILE_SPECIFIER=#{profile_uuid}",
      'ONLY_ACTIVE_ARCH=NO',
      '-showBuildTimingSummary',  
      '-parallelizeTargets'       
    ].join(' ')
    
    begin
      gym(
        project: XCODEPROJ,
        scheme: SCHEME,
        configuration: 'Release',
        export_method: 'app-store',
        clean: true,
        include_bitcode: false,
        export_options: {
          method: 'app-store',
          signingStyle: 'manual',
          provisioningProfiles: { APP_IDENTIFIER => profile_uuid }
        },
        xcargs: xc,
        output_directory: '.',
        output_name: IPA_NAME
      )
    ensure
      UI.message("ğŸ—‘ï¸ åˆªé™¤è‡¨æ™‚ keychain: #{keychain_name}")
      delete_keychain(name: keychain_name)
    end
  end

  desc 'ä¸Šå‚³ TestFlight'
  lane :beta do
    build
    pilot(
      api_key: fetch_api_key! ,
      ipa: "#{IPA_NAME}.ipa",
      skip_waiting_for_build_processing: false
    )
  end

  desc 'ä¸Šå‚³è‡³ App Store Connectï¼ˆå¯é¸é€å¯©/è‡ªå‹•ç™¼å¸ƒï¼‰'
  lane :release do
    build

    submit_for_review = ENV['SUBMIT_FOR_REVIEW'] == 'true'
    automatic_release = ENV['AUTOMATIC_RELEASE'] == 'true'

    begin
      deliver(
        api_key: fetch_api_key!,
        ipa: "#{IPA_NAME}.ipa",
        submit_for_review: submit_for_review,
        automatic_release: automatic_release,
        submission_information: export_compliance_info,
        skip_metadata: true,
        skip_screenshots: true,
        force: true,
        precheck_include_in_app_purchases: false,
        run_precheck_before_submit: true
      )
    rescue => ex
      if ex.message.include?('A relationship value is not acceptable for the current resource state')
        UI.important('[è‡ªå‹•é‡è©¦] Build å°šæœª readyï¼Œ5 åˆ†é˜å¾Œæ”¹ä»¥ skip_binary_upload=1 åƒ…é€å¯©')
        sleep(300)
        deliver(
          api_key: fetch_api_key!,
          submit_for_review: submit_for_review,
          automatic_release: automatic_release,
          submission_information: export_compliance_info,
          skip_binary_upload: true,
          skip_metadata: true,
          skip_screenshots: true,
          force: true,
          precheck_include_in_app_purchases: false,
          run_precheck_before_submit: true
        )
      else
        raise ex
      end
    end
  end
end
